O site nÃ£o tÃ¡ segurando os usuÃ¡rios dentro da partida corretamente. Em momentos do jogo que nÃ£o Ã© necessario a interaÃ§Ã£o com o site, os jogadores ficam inativos, mas com a tela do celular/computador aberta. SÃ³ que da mesma forma o site nÃ£o segura corretamente os jogadores os deixando na partida. As vezes um jogador parece que saiu do servidor para os outros usuarios, mas para ele ainda estÃ¡ lÃ¡.

As vezes parece que ele saiu para os outros usuarios, o proprio usuario que caiu tambem nÃ£o ve mais seu nome no lobby, mas continua dentro do servidor, sÃ³ que impossibilitado de jogar. E o host tambÃ©m nÃ£o consegue comeÃ§ar a partida caso haja sÃ³ tres jogadores, jogando, pois se tivessem 4 jogadores, daria para iniciar a partida, mas o usuario com problema fica parecendo um ghost no servidor 

Quero que vocÃª implemente correÃ§Ãµes no meu sistema de multiplayer para evitar jogadores fantasmas e desconexÃµes silenciosas. O problema atual Ã© o seguinte:

Quando os jogadores ficam inativos sem interaÃ§Ã£o, alguns acabam desconectando parcialmente.

Para alguns usuÃ¡rios o jogador parece ter saÃ­do do lobby, mas para ele mesmo nÃ£o.

Isso cria um jogador fantasma (ghost player) no servidor.

O host nÃ£o consegue iniciar o jogo porque o servidor acha que existem mais jogadores conectados do que realmente existem.

Quero que vocÃª implemente todas as correÃ§Ãµes listadas abaixo no backend e frontend:

ðŸ”¥ Objetivos principais

Criar heartbeat (ping-pong) entre cliente e servidor.

Detectar jogadores inativos e removÃª-los de forma confiÃ¡vel.

Implementar reconexÃ£o automÃ¡tica quando o WebSocket cair ou ficar suspenso.

Criar um sistema de sincronizaÃ§Ã£o (sync_request) quando a aba voltar a ter foco.

Impedir o host de iniciar partida com jogadores fantasmas.

ðŸ§© ImplementaÃ§Ã£o no Servidor (WebSocket/Node)
O que fazer no backend:

Manter um registro lastPong para cada jogador conectado.

A cada 5 segundos enviar ping para todos os jogadores.

Se um jogador nÃ£o responder em atÃ© 10 segundos, removÃª-lo da sala.

Toda alteraÃ§Ã£o deve disparar broadcastLobby() para atualizar todos os clientes.

Implementar rota para sync_request que envia o estado da sala atualizado.

No inÃ­cio da partida validar apenas jogadores ativos com lastPong recente.

Estrutura esperada:
setInterval(() => {
  for (const player of players) {
    if (Date.now() - player.lastPong > 10000) {
      removePlayer(player.id);
      broadcastLobby();
    } else {
      player.ws.send(JSON.stringify({ type: "ping" }));
    }
  }
}, 5000);

onMessage(data) {
  if (data.type === "pong") {
    player.lastPong = Date.now();
  }

  if (data.type === "sync_request") {
    sendCurrentLobbyState(player.id);
  }
}

ðŸ§© ImplementaÃ§Ã£o no Frontend
Requisitos do cliente:

Quando receber ping, responder pong.

Detectar perda de conexÃ£o e tentar reconectar automaticamente.

Usar backoff para reconexÃµes (1.5s / 3s / 5s).

Ao recuperar foco da aba, enviar sync_request.

Se reconectar, solicitar estado do lobby imediatamente.

Estrutura esperada:
function connect() {
  socket = new WebSocket(SERVER_URL);

  socket.onopen = () => socket.send(JSON.stringify({ type: "sync_request" }));

  socket.onmessage = msg => {
    const data = JSON.parse(msg.data);
    if (data.type === "ping") socket.send(JSON.stringify({ type: "pong" }));
  };

  socket.onclose = () => setTimeout(connect, 1500);
  socket.onerror = () => socket.close(); 
}

window.addEventListener("focus", () => {
  socket.send(JSON.stringify({ type: "sync_request" }));
});

connect();

CritÃ©rio de aceitaÃ§Ã£o

âœ” Jogadores fantasmas nunca devem existir
âœ” Se o cliente desconectar, ele deve reconectar sozinho
âœ” Se o socket ficar suspenso por inatividade, sync deve corrigir lobby
âœ” Host sÃ³ pode iniciar jogo com players ativos de verdade
âœ” Todos os usuÃ¡rios veem o mesmo estado sempre